#include "I2C.h"
#include <stdio.h>

void I2C_INIT(
	)
{
	//I2C CLOCK ENABLE
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	
	//GPIOx CLOCK ENABLE, PINS B6 AND B7
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
	
	//CONNECT I2C PINS TO AF
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
	
	//GPIO PINS CONFIGURATION
	//B6 AND B7 AS Alternate function output Open-drain AND Output mode, max speed 50 MHz.
	GPIOB->CRL |= GPIO_CRL_CNF6 | GPIO_CRL_MODE6 | GPIO_CRL_CNF7 | GPIO_CRL_MODE7;
	
	/**I2C INIT**/
	//CLOCK SPEED
	I2C1->CR2 |= I2C_CR2_FREQ_3;
	
	//DUTY CYCLE
	I2C1->CR1 &= ~I2C_CR1_PE;	//PERIPHERAL DISABLE TO CONFIGURE CCR REGISTER
	I2C1->CCR &= ~I2C_CCR_FS;	//STANDARD MODE
	I2C1->CCR |= 40;					//TO KNOW CCR VALUE--> CCR = (1/(2*SCL FREQUENCY))/(1/FREQ IN CR2)
	
	//TRISE
	I2C1->TRISE = 9;
	
	//ACK ENABLE
	I2C1->CR1 |= I2C_CR1_ACK;
	
	//ACK ADDRESS -> 7 BITS
	I2C1->OAR1 &= ~I2C_OAR1_ADDMODE;	//7 BITS ADDRESS
	I2C1->OAR1 |= I2C_OAR1_ADD1;			//OWN ADDRESS IS 1
	
	//ENABLE CLOCK STRETCHING
	I2C1->CR1 &= ~I2C_CR1_NOSTRETCH;
	
	//PERIPHERAL ENABLE
	I2C1->CR1 |= I2C_CR1_PE;	
}

void I2C_SEND_BYTE(
uint8_t address,
uint8_t data
	)
{
	char read;
	//START CONDITION
	I2C1->CR1 |= I2C_CR1_START;	//SEND START BIT
	while(!(I2C1->SR1 & I2C_SR1_SB)){}
	//read = I2C1->SR1 & I2C_SR1_SB;
	//read = I2C1->SR2 & I2C_SR2_BUSY;
	//while(I2C1->SR2 & I2C_SR2_BUSY);
	
	//SEND SLAVE ADDRESS AND WAIT FOR ADDR TO BE SET AND CLEAR IT
	I2C1->DR = address;
	//while(!(I2C1->SR1 & I2C_SR1_ADDR)){}
	read = I2C1->SR1;
	read = I2C1->SR2;
	//if(I2C1->SR2 & I2C_SR2_TRA);
	
	//WAIT FOR TRANSMISSION TO BE COMPLETED (BTF IS SET)
	while(!(I2C1->SR1 & ~I2C_SR1_TXE)){}
		
	//WRITE DATA IN DR
	//while(I2C1->SR2 & I2C_SR2_BUSY);
	I2C1->DR = data;
	
	//WAIT FOR TRANSMISSION TO BE COMPLETED (BTF IS SET)
	while(!(I2C1->SR1 & ~I2C_SR1_TXE)){}

	//SEND STOP BIT
	I2C1->CR1 |= I2C_CR1_STOP;
	
	//WAIT FOR STOP BIT TO BE CLEARED BY HARDWARE
	while(I2C1->CR1 & I2C_CR1_STOP){}
}

char I2C_RECEIVE_BYTE
	()
{
	char ADDRESS, READ, DATA;
	while (!(ADDRESS == I2C1->OAR1)){}	//WAIT TO RECEIVE ADDRESS
	READ = I2C1->SR1;
	READ = I2C1->SR2;
	//WAIT FOR TRANSMISSION TO BE COMPLETED (BTF IS SET)
	while(!(I2C1->SR1 & ~I2C_SR1_TXE)){}
	DATA = I2C1->DR;
	//WAIT FOR TRANSMISSION TO BE COMPLETED (BTF IS SET)
	while(!(I2C1->SR1 & ~I2C_SR1_TXE)){}
	return DATA;
}
